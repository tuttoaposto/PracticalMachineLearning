<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Data partition</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<p>###Title: Practical Machine Learning Project<br/>
###Objective: Predict how well people perform weight lifting exercise using data from accelerometers on the belt 
###<br></p>

<h3>Data partition</h3>

<p>Since the test data does not have the response variable to test for prediction accuracy, here we create a validation set to validate the model selected. We will partition the training data into a training set and a validation set in 0.75 and 0.25 ratio. The training set will be used to build the model, which will be used for prediction on the validation set. The predicted response will be compared to the reference response variable in the validation set for accuracy check.</p>

<p>Before partitioning the training data, we will exclude some variables that do not contribute to the prediction algorithm. We will remove predictors that have lots of missing values (&#39;NA&#39; or &#39;&#39;) since they do not have enough information to predict well. We will also remove measurement unrelated variables (e.g user name and timestamps).</p>

<pre><code class="r">#Read in training data
if (!file.exists(&#39;pml-training.csv&#39;))
  download.file(&#39;https://d396qusza40orc.cloudfront.net/predmachlearn/pml-training.csv&#39;, &#39;pml-training.csv&#39;)

training &lt;- read.csv(&#39;pml-training.csv&#39;, header = T, na.strings = c(&#39;NA&#39;, &#39;&#39;))

#Outcome variable
rbind(n = table(training$classe), pct = round(prop.table(table(training$classe))*100, 2))
</code></pre>

<pre><code>##           A       B       C       D       E
## n   5580.00 3797.00 3422.00 3216.00 3607.00
## pct   28.44   19.35   17.44   16.39   18.38
</code></pre>

<pre><code class="r">#Get predcitors that are non-missing in the training dataset
nonMiss &lt;- as.character()
for (i in 1 : ncol(training))
    if (sum(!is.na(training[ ,i])) == nrow(training))  
          nonMiss &lt;- c(nonMiss, colnames(training[i]))

nonMiss #down to 60 columns
</code></pre>

<pre><code>##  [1] &quot;X&quot;                    &quot;user_name&quot;            &quot;raw_timestamp_part_1&quot;
##  [4] &quot;raw_timestamp_part_2&quot; &quot;cvtd_timestamp&quot;       &quot;new_window&quot;          
##  [7] &quot;num_window&quot;           &quot;roll_belt&quot;            &quot;pitch_belt&quot;          
## [10] &quot;yaw_belt&quot;             &quot;total_accel_belt&quot;     &quot;gyros_belt_x&quot;        
## [13] &quot;gyros_belt_y&quot;         &quot;gyros_belt_z&quot;         &quot;accel_belt_x&quot;        
## [16] &quot;accel_belt_y&quot;         &quot;accel_belt_z&quot;         &quot;magnet_belt_x&quot;       
## [19] &quot;magnet_belt_y&quot;        &quot;magnet_belt_z&quot;        &quot;roll_arm&quot;            
## [22] &quot;pitch_arm&quot;            &quot;yaw_arm&quot;              &quot;total_accel_arm&quot;     
## [25] &quot;gyros_arm_x&quot;          &quot;gyros_arm_y&quot;          &quot;gyros_arm_z&quot;         
## [28] &quot;accel_arm_x&quot;          &quot;accel_arm_y&quot;          &quot;accel_arm_z&quot;         
## [31] &quot;magnet_arm_x&quot;         &quot;magnet_arm_y&quot;         &quot;magnet_arm_z&quot;        
## [34] &quot;roll_dumbbell&quot;        &quot;pitch_dumbbell&quot;       &quot;yaw_dumbbell&quot;        
## [37] &quot;total_accel_dumbbell&quot; &quot;gyros_dumbbell_x&quot;     &quot;gyros_dumbbell_y&quot;    
## [40] &quot;gyros_dumbbell_z&quot;     &quot;accel_dumbbell_x&quot;     &quot;accel_dumbbell_y&quot;    
## [43] &quot;accel_dumbbell_z&quot;     &quot;magnet_dumbbell_x&quot;    &quot;magnet_dumbbell_y&quot;   
## [46] &quot;magnet_dumbbell_z&quot;    &quot;roll_forearm&quot;         &quot;pitch_forearm&quot;       
## [49] &quot;yaw_forearm&quot;          &quot;total_accel_forearm&quot;  &quot;gyros_forearm_x&quot;     
## [52] &quot;gyros_forearm_y&quot;      &quot;gyros_forearm_z&quot;      &quot;accel_forearm_x&quot;     
## [55] &quot;accel_forearm_y&quot;      &quot;accel_forearm_z&quot;      &quot;magnet_forearm_x&quot;    
## [58] &quot;magnet_forearm_y&quot;     &quot;magnet_forearm_z&quot;     &quot;classe&quot;
</code></pre>

<pre><code class="r">#Remove non-measurement related columns
nonMiss &lt;- nonMiss[-c(1:7)]

training &lt;- training[ , nonMiss] 
dim(training) #19622, 53
</code></pre>

<pre><code>## [1] 19622    53
</code></pre>

<pre><code class="r">library(caret)
</code></pre>

<pre><code>## Loading required package: lattice
## Loading required package: ggplot2
</code></pre>

<pre><code class="r">#Separate into training set and validation set
set.seed(123)
inTrain = createDataPartition(training$classe, p = 3/4)[[1]]
train &lt;- training[inTrain, ]  
valid &lt;- training[-inTrain, ]

dim(train); dim(valid)#14718 vs 4904
</code></pre>

<pre><code>## [1] 14718    53
</code></pre>

<pre><code>## [1] 4904   53
</code></pre>

<h3>Model building and validation</h3>

<p>Different recursive partitioning tree models will be fitted to the training set: 1) model without repeated sampling of observations or bagging (rpart); 2) model with bagging (treebag); 3) model involves both bagging of the observations and predictors (random forest). With extensve resampling of observations and predictors, we expect random forest gives the best prediction. All models have cross-validation applied.</p>

<p>Model #1: rpart</p>

<pre><code class="r">set.seed(101)
fit_rpart &lt;- train(classe ~., method = &#39;rpart&#39;, data = train,
                   trControl = trainControl(method = &#39;cv&#39;, number = 5))
</code></pre>

<pre><code>## Loading required package: rpart
</code></pre>

<pre><code class="r">fit_rpart$finalModel
</code></pre>

<pre><code>## n= 14718 
## 
## node), split, n, loss, yval, (yprob)
##       * denotes terminal node
## 
##  1) root 14718 10533 A (0.28 0.19 0.17 0.16 0.18)  
##    2) roll_belt&lt; 130.5 13487  9310 A (0.31 0.21 0.19 0.18 0.11)  
##      4) pitch_forearm&lt; -33.95 1199     9 A (0.99 0.0075 0 0 0) *
##      5) pitch_forearm&gt;=-33.95 12288  9301 A (0.24 0.23 0.21 0.2 0.12)  
##       10) magnet_dumbbell_y&lt; 439.5 10359  7433 A (0.28 0.18 0.24 0.19 0.11)  
##         20) roll_forearm&lt; 122.5 6429  3806 A (0.41 0.18 0.18 0.17 0.059) *
##         21) roll_forearm&gt;=122.5 3930  2613 C (0.077 0.17 0.34 0.23 0.18) *
##       11) magnet_dumbbell_y&gt;=439.5 1929   955 B (0.032 0.5 0.043 0.22 0.2) *
##    3) roll_belt&gt;=130.5 1231     8 E (0.0065 0 0 0 0.99) *
</code></pre>

<pre><code class="r">fit_rpart$results
</code></pre>

<pre><code>##           cp  Accuracy      Kappa AccuracySD    KappaSD
## 1 0.03588721 0.5222917 0.38060835 0.03603623 0.05489415
## 2 0.06098294 0.4156769 0.20796621 0.06811534 0.11449126
## 3 0.11535175 0.3310170 0.07131806 0.04257919 0.06513305
</code></pre>

<pre><code class="r">library(rattle)
</code></pre>

<pre><code>## Loading required package: RGtk2
## Rattle: A free graphical interface for data mining with R.
## Version 3.5.0 Copyright (c) 2006-2015 Togaware Pty Ltd.
## Type &#39;rattle()&#39; to shake, rattle, and roll your data.
</code></pre>

<pre><code class="r">fancyRpartPlot(fit_rpart$finalModel, sub = &#39;&#39;)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-2"/> </p>

<pre><code class="r">pred_rpart &lt;- predict(fit_rpart, newdata = valid)
cm &lt;- confusionMatrix(pred_rpart, valid$classe)

options(scipen = 100)
cm$table; cm$overall[1:4]
</code></pre>

<pre><code>##           Reference
## Prediction    A    B    C    D    E
##          A 1262  378  418  356  144
##          B   20  312   26  141  101
##          C  107  259  411  307  248
##          D    0    0    0    0    0
##          E    6    0    0    0  408
</code></pre>

<pre><code>##      Accuracy         Kappa AccuracyLower AccuracyUpper 
##     0.4879690     0.3307469     0.4738877     0.5020646
</code></pre>

<p>The dentrogram shows that the classification in the final nodes highly deviates from the actual classification. For example, in node #20, 44% of the data was classified to A while the actual proportion was only 28%. No node led to Class D.</p>

<p>Numerically, the simple tree model has low prediction accuracy at 48.8% or high out of sample error at 51.2%.</p>

<p>###<br></p>

<p>Model #2: treebag</p>

<pre><code class="r">set.seed(102)
fit_bag &lt;- train(classe ~., method = &#39;treebag&#39;, data = train,
                   trControl = trainControl(method = &#39;cv&#39;, number = 5))
</code></pre>

<pre><code>## Loading required package: ipred
## Loading required package: plyr
## Loading required package: e1071
</code></pre>

<pre><code class="r">fit_bag$finalModel
</code></pre>

<pre><code>## 
## Bagging classification trees with 25 bootstrap replications
</code></pre>

<pre><code class="r">fit_bag$results
</code></pre>

<pre><code>##   parameter  Accuracy     Kappa AccuracySD     KappaSD
## 1      none 0.9836936 0.9793726 0.00626867 0.007929726
</code></pre>

<pre><code class="r">pred_bag &lt;- predict(fit_bag, newdata = valid)
cm &lt;- confusionMatrix(pred_bag, valid$classe)

cm$table; cm$overall[1:4]
</code></pre>

<pre><code>##           Reference
## Prediction    A    B    C    D    E
##          A 1391    8    1    2    0
##          B    1  923   12    1    3
##          C    1   12  834   15    0
##          D    1    5    8  783    2
##          E    1    1    0    3  896
</code></pre>

<pre><code>##      Accuracy         Kappa AccuracyLower AccuracyUpper 
##     0.9842985     0.9801365     0.9804144     0.9875893
</code></pre>

<p>With repeated sampling, the accuracies for both the training and validation sets have improved a lot to &gt;98%.</p>

<p>####<br></p>

<p>Model #3: random forest</p>

<pre><code class="r">set.seed(103)
fit_rf &lt;- train(classe ~., method = &#39;rf&#39;, data = train,
                   trControl = trainControl(method = &#39;cv&#39;, number = 5))
</code></pre>

<pre><code>## Loading required package: randomForest
## randomForest 4.6-12
## Type rfNews() to see new features/changes/bug fixes.
</code></pre>

<pre><code class="r">fit_rf
</code></pre>

<pre><code>## Random Forest 
## 
## 14718 samples
##    52 predictor
##     5 classes: &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39; 
## 
## No pre-processing
## Resampling: Cross-Validated (5 fold) 
## Summary of sample sizes: 11774, 11774, 11774, 11775, 11775 
## Resampling results across tuning parameters:
## 
##   mtry  Accuracy   Kappa      Accuracy SD   Kappa SD   
##    2    0.9911673  0.9888258  0.0008660035  0.001095524
##   27    0.9906915  0.9882245  0.0014941943  0.001890301
##   52    0.9849839  0.9810049  0.0032293211  0.004086972
## 
## Accuracy was used to select the optimal model using  the largest value.
## The final value used for the model was mtry = 2.
</code></pre>

<pre><code class="r">fit_rf$finalModel
</code></pre>

<pre><code>## 
## Call:
##  randomForest(x = x, y = y, mtry = param$mtry) 
##                Type of random forest: classification
##                      Number of trees: 500
## No. of variables tried at each split: 2
## 
##         OOB estimate of  error rate: 0.58%
## Confusion matrix:
##      A    B    C    D    E  class.error
## A 4184    1    0    0    0 0.0002389486
## B   13 2828    7    0    0 0.0070224719
## C    0   18 2544    5    0 0.0089598753
## D    0    0   37 2375    0 0.0153399668
## E    0    0    1    4 2701 0.0018477458
</code></pre>

<pre><code class="r">pred_rf &lt;- predict(fit_rf, newdata = valid)
cm &lt;- confusionMatrix(pred_rf, valid$classe)

cm$table; cm$overall[1:4]
</code></pre>

<pre><code>##           Reference
## Prediction    A    B    C    D    E
##          A 1394    3    0    0    0
##          B    1  944    8    0    0
##          C    0    2  847   19    0
##          D    0    0    0  783    2
##          E    0    0    0    2  899
</code></pre>

<pre><code>##      Accuracy         Kappa AccuracyLower AccuracyUpper 
##     0.9924551     0.9904556     0.9896153     0.9946823
</code></pre>

<pre><code class="r">varImp(fit_rf, scale = T)
</code></pre>

<pre><code>## rf variable importance
## 
##   only 20 most important variables shown (out of 52)
## 
##                   Overall
## roll_belt          100.00
## yaw_belt            77.99
## magnet_dumbbell_z   68.03
## magnet_dumbbell_y   64.24
## pitch_belt          62.04
## pitch_forearm       58.99
## magnet_dumbbell_x   52.86
## roll_forearm        52.73
## accel_dumbbell_y    45.47
## accel_belt_z        44.96
## magnet_belt_z       44.10
## roll_dumbbell       41.93
## magnet_belt_y       40.45
## accel_dumbbell_z    38.35
## roll_arm            33.70
## accel_forearm_x     31.12
## magnet_forearm_z    29.35
## accel_dumbbell_x    29.30
## yaw_dumbbell        29.15
## gyros_belt_z        28.84
</code></pre>

<p>With bagging of predictors, we allow to build more trees than the above two models (hence it&#39;s called random forest) and thus it takes the longest computation time. But it results in excellent accuracy at 99.3%, or out of sample error at 0.7%.</p>

<p>The list of top 20 predictors shows that roll_belt has the best prediction power.</p>

<p>###<br></p>

<h3>Prediction with final model</h3>

<p>Owing to the most superior accuracy of random forest classification, we adopt the last model for prediction on the test data. Likewise, we will remove non-predicting variables.</p>

<pre><code class="r">#Read in test data
if (!file.exists(&#39;pml-testing.csv&#39;))
  download.file(&#39;https://d396qusza40orc.cloudfront.net/predmachlearn/pml-testing.csv&#39;, &#39;pml-testing.csv&#39;)
testing &lt;- read.csv(&#39;pml-testing.csv&#39;, header = T)

#Remove non-predicting columns
nonMiss &lt;- as.character()
for (i in 1 : ncol(testing))
    if (sum(!is.na(testing[ ,i])) == nrow(testing))  
          nonMiss &lt;- c(nonMiss, colnames(testing[i]))

nonMiss #down to 60 columns
</code></pre>

<pre><code>##  [1] &quot;X&quot;                    &quot;user_name&quot;            &quot;raw_timestamp_part_1&quot;
##  [4] &quot;raw_timestamp_part_2&quot; &quot;cvtd_timestamp&quot;       &quot;new_window&quot;          
##  [7] &quot;num_window&quot;           &quot;roll_belt&quot;            &quot;pitch_belt&quot;          
## [10] &quot;yaw_belt&quot;             &quot;total_accel_belt&quot;     &quot;gyros_belt_x&quot;        
## [13] &quot;gyros_belt_y&quot;         &quot;gyros_belt_z&quot;         &quot;accel_belt_x&quot;        
## [16] &quot;accel_belt_y&quot;         &quot;accel_belt_z&quot;         &quot;magnet_belt_x&quot;       
## [19] &quot;magnet_belt_y&quot;        &quot;magnet_belt_z&quot;        &quot;roll_arm&quot;            
## [22] &quot;pitch_arm&quot;            &quot;yaw_arm&quot;              &quot;total_accel_arm&quot;     
## [25] &quot;gyros_arm_x&quot;          &quot;gyros_arm_y&quot;          &quot;gyros_arm_z&quot;         
## [28] &quot;accel_arm_x&quot;          &quot;accel_arm_y&quot;          &quot;accel_arm_z&quot;         
## [31] &quot;magnet_arm_x&quot;         &quot;magnet_arm_y&quot;         &quot;magnet_arm_z&quot;        
## [34] &quot;roll_dumbbell&quot;        &quot;pitch_dumbbell&quot;       &quot;yaw_dumbbell&quot;        
## [37] &quot;total_accel_dumbbell&quot; &quot;gyros_dumbbell_x&quot;     &quot;gyros_dumbbell_y&quot;    
## [40] &quot;gyros_dumbbell_z&quot;     &quot;accel_dumbbell_x&quot;     &quot;accel_dumbbell_y&quot;    
## [43] &quot;accel_dumbbell_z&quot;     &quot;magnet_dumbbell_x&quot;    &quot;magnet_dumbbell_y&quot;   
## [46] &quot;magnet_dumbbell_z&quot;    &quot;roll_forearm&quot;         &quot;pitch_forearm&quot;       
## [49] &quot;yaw_forearm&quot;          &quot;total_accel_forearm&quot;  &quot;gyros_forearm_x&quot;     
## [52] &quot;gyros_forearm_y&quot;      &quot;gyros_forearm_z&quot;      &quot;accel_forearm_x&quot;     
## [55] &quot;accel_forearm_y&quot;      &quot;accel_forearm_z&quot;      &quot;magnet_forearm_x&quot;    
## [58] &quot;magnet_forearm_y&quot;     &quot;magnet_forearm_z&quot;     &quot;problem_id&quot;
</code></pre>

<pre><code class="r">nonMiss &lt;- nonMiss[-c(1:7, 60)]

testing &lt;- testing[ , nonMiss]
dim(testing) #20 obs. of  52 variables
</code></pre>

<pre><code>## [1] 20 52
</code></pre>

<pre><code class="r">pred &lt;- predict(fit_rf, newdata = testing)
pred
</code></pre>

<pre><code>##  [1] B A B A A E D B A A B C B A E E A B B B
## Levels: A B C D E
</code></pre>

<p>###<br></p>

<p>####Let&#39;s check the answers with the submission program</p>

<pre><code class="r">source(&#39;pml_write_files.R&#39;)
pml_write_files(pred)
letter &lt;- as.character()
for (i in 1:20){
  x &lt;- read.table(paste(&#39;problem_id_&#39;, i, &#39;.txt&#39;, sep = &#39;&#39;), stringsAsFactors = F)
  x &lt;-as.character(x)
  letter &lt;- c(letter, x)
}
letter
</code></pre>

<pre><code>##  [1] &quot;B&quot; &quot;A&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;E&quot; &quot;D&quot; &quot;B&quot; &quot;A&quot; &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;B&quot; &quot;A&quot; &quot;E&quot; &quot;E&quot; &quot;A&quot;
## [18] &quot;B&quot; &quot;B&quot; &quot;B&quot;
</code></pre>

<p>All answers are correct!</p>

<p>###<br></p>

<h3>Citations</h3>

<p>Velloso, E.; Bulling, A.; Gellersen, H.; Ugulino, W.; Fuks, H. Qualitative Activity Recognition of Weight Lifting Exercises. Proceedings of 4th International Conference in Cooperation with SIGCHI (Augmented Human &#39;13) . Stuttgart, Germany: ACM SIGCHI, 2013.</p>

</body>

</html>
